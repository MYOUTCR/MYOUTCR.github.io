<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Template Method]]></title>
      <url>%2F2019%2F12%2F23%2FTemplateMethod%2F</url>
      <content type="text"><![CDATA[意图: 定义一个操作中的算法骨架,而将一些步骤延迟到子类中。模板方法使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。 何时使用: 一些方法通用,却在每个子类中都重写了这一方法。 如何解决: 将这些通用方法抽象出来。 关键代码: 在抽象类实现,其他步骤在子类中实现。 应用实例: 优点: 封装不变部分,扩展可变部分。 提取公共代码便于维护。 行为由父类控制,子类实现。 缺点: 每一个不同的实现都需要一个子类来实现,导致类的个数增加,系统更加庞大。 使用场景: 有多个子类共有的方法,且逻辑相同。 重要的、复杂的方法,可以考虑使用模板方法。 注意事项: 为防止恶意操作,一般模板方法都加上final关键词。 实现: 创建一个定义操作Game抽象类,其中模板方法设置为final,这样它就不会被重写。ch1和ch1扩展了Game实体类，它们重写了抽象类的方法。 1234567891011121314151617class Game&#123;public: Game() &#123;&#125;; ~Game() &#123;&#125;; virtual void play() final &#123; initialize(); startPlay(); endPlay(); &#125; virtual void initialize() = 0; virtual void startPlay() = 0; virtual void endPlay() = 0;&#125;; 12345678910111213141516171819class Cricket:public Game&#123;public: Cricket() &#123;&#125; ~Cricket() &#123;&#125;; virtual void initialize() &#123; cout &lt;&lt; "Cricket Game initialize playing" &lt;&lt; endl; &#125; virtual void startPlay() &#123; cout &lt;&lt; "Cricket Game startPlay playing" &lt;&lt; endl; &#125; virtual void endPlay() &#123; cout &lt;&lt; "Cricket Game endPlay playing" &lt;&lt; endl; &#125;&#125;; 12345678910111213141516171819202122232425class Football:public Game&#123;public: Football() &#123;&#125; ~Football() &#123;&#125;; virtual void initialize() &#123; cout &lt;&lt; "Football Game initialize playing" &lt;&lt; endl; &#125; virtual void startPlay() &#123; cout &lt;&lt; "Football Game startPlay playing" &lt;&lt; endl; &#125; virtual void endPlay() &#123; cout &lt;&lt; "Football Game endPlay playing" &lt;&lt; endl; &#125;// virtual void play()//无法被重写// &#123;// cout &lt;&lt; "Football Game play playing" &lt;&lt; endl;// &#125;&#125;; 123456789101112int main()&#123; Game *cricketGame = new Cricket(); cricketGame-&gt;play(); cout &lt;&lt; "\n\n"&lt;&lt;endl; Game *FootballGame = new Football(); FootballGame-&gt;play(); getchar();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OSG场景的组织结构]]></title>
      <url>%2F2018%2F06%2F04%2FOSG%E5%9C%BA%E6%99%AF%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[OSG采用包围层次BVH,其中采用树结构保存数据。OSG采用Node类来表达一个基本节点，也就是作为所有节点的基类，它需要一个BoundingSpherre类来表达自己的包围球形体。并且需要一些方法来更新包围球的大小。当节点发生变化时（删除、增加，改变自身包围球形状），需要重新计算该节点的包围球数据，并递归到根节点，以便维护场景BVH树的可用性。 osg::Node类Node()//默认构造函数 void dirtyBound()\\提示更新节点的包围体 const BoudingSpere&amp; getBound() const \\获取节点包围体 BoudingSpere computerBound() const \\虚函数，计算节点包围体 const ParentList getParents() const\\获取节点的父节点列表 const Group* getParent(unsigned int i)const \\获取指定的父节点 unsigned int getNumParents() const \\获取父节点数目 void AddParent(Group *node) \\为当前节点追加一个父节点 强制重新计算并获取包围求数据 node-&gt;dirtyBound(); osg::getBoundingSphere&amp; bs=node-&gt;getBOund(); 父节点与子节点关系一个场景树包含一个根节点、多级内部枝节节点，以及都哟个末端的叶子接待你。OSG场景为一种有向无环图(DAG)。 在DAG层次中，多个父节点共享一个子节点的情况十分普遍，我们称为对这个子节点的“实例化”（Instance）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习路线]]></title>
      <url>%2F2018%2F05%2F19%2FPython%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
      <content type="text"><![CDATA[python基础知识Python手册 python基础教程 正则表达式 正则表达式 XPath表达式 掌握urllib模块 Urllib手册 掌握抓包技术Fiddler 简书Fiddler教程 Fiddler手册 掌握Scrapy框架 Scrapy手册 掌握常见的反爬策略与反爬处理策略 反爬虫策略 掌握PhantomJS、Selenium等工具的使用 PhantomJS,Selenium教程 PhantomJS手册 Selenium手册 掌握分布式爬虫技术与数据去重技术 简单分布式爬虫 数据去重]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL Server基础]]></title>
      <url>%2F2018%2F05%2F19%2FSQL%20Server%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[创建数据库语法： CREATE DATABASE 数据库名称 实例：CREATE DATABASE TDB_SQL 切换到相应数据库下语法： USE 数据库名称 USE TDB_SQL 创建数据表语法: CREATE TABLE 表格名(列明 属性信息，…) CREATE TABLE customer(Frist_Name char(50),Last_Name char(50),Address char(100),City char(50),Country char(50),Brith_Date date) 数据库添加列语法: ALTER TABLE 表格名 ADD 添加的列名 列名属性信息 ALTER TABLE Coustomer Add AddCol char(50) NOT NULL 删除列语法: ALTER TABLE 表格名 DROP COLUMN 要删除的列名 ALTER TABLE Coustomer DROP COLUMN ReCol 删除表DROP TABLE 用户信息表 清除表格中的所有数据语法：TRUNCATE TABLE 表格名称 TRUNCATE TABLE customer_one 更改列名称语法: sp_rename ‘表格名.列名’,更改后的列名,’COLUMN’ sp_rename &apos;Coustomer.AddCol&apos;,ReCol ,&apos;COLUMN&apos; 插入语句语法：（单行插入） INSERT INTO 表格名(列名1,列名2，…) VALUES (列名1对应值,列名2对应值,…)语法：（多行行插入） INSERT INTO 表格名(列名1,列名2，…) VALUES (列名1对应值,列名2对应值,…),(列名1对应值,列名2对应值,…)… INSERT INTO customer(Frist_Name,Last_Name,Address,City,Country,Brith_Date) VALUES(&apos;f1&apos;,&apos;L1&apos;,&apos;A1&apos;,&apos;C1&apos;,&apos;COU1&apos;,NULL),(&apos;f2&apos;,&apos;L2&apos;,&apos;A2&apos;,&apos;C2&apos;,&apos;COU2&apos;,NULL) 查询数据语法 SELECT 列名 FROM 表格名 SELECT UserName FROM Coustomer SELECT UserName,City FROM Coustomer 去掉查找到重复的数据 SELECT DISTINCT Country FROM Coustomer 更改内容UPDATE TestTABLE SET name=&apos;6&apos; 关键字 WHERE 关键字:条件过滤 语法:SELECT “列名” FROM “表格名” WHERE “条件” SELECT UserName,City,Country FROM Coustomer WHERE Country=&apos;中国&apos; AND City=&apos;武汉&apos; IN 关键字1.与WHERE有多个相等的值时 SELECT UserName,City,Country FROM Coustomer WHERE Country IN (&apos;中国&apos;,&apos;jp&apos;) LIKE关键字 语法：SELECT 列名 FROM 表格名 WHERE 列名 LIKE{模式} SELECT UserName,City,Country FROM Coustomer WHERE Country LIKE&apos;%国&apos; OR Country LIKE&apos;%P&apos; ORDER BY 关键字ASC 从小到大，DESC 从大到小，默认是ASC 语法：SELECT 列名FROM 表格名WHERE 条件 ORDER BY 列名 [ASC,DESC] SELECT UserName,City,Country FROM Coustomer ORDER BY UserName DESC 函数 SELECT 函数(列名) FROM 表格名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++ 数据类型]]></title>
      <url>%2F2017%2F05%2F18%2FC-DataType%2F</url>
      <content type="text"><![CDATA[C++数据类型 类型 关键字 描述 布尔型 bool 存储值True 或false 字符型 char 通常一个八位(一个字节),这是一个整数类型 整型 int 整数类型 浮点型 float 单精度浮点值 双浮点型 double 双精度浮点值 无类型 void 空类型(可强制转换成任意类型) 宽字符型 wchar_t 宽字符类型（双字节） 一个字符可以用一个或多个类型修饰符进行修饰,一般程序默认为有符号类型。 Signed unsigned short long 下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。 类型 位 范围 char 1字节 -128到127 或0到125 unsigned char 1字节 0到125 int 4字节 -2147483648 到 2147483647 unsigned int 4字节 0 到 4294967295 short int 2字节 -216-1 到 216-1-1 unsigned short int 2字节 0 到 216-1 long int 8字节 -264-1 到-264-1-1 unsigned long int 8字节 0 to 264-1 float 4字节 +/- 3.4e +/- 38 (~7 个数字) double 8字节 +/- 1.7e +/- 308 (~15 个数字) float和double的范围是由指数的位数来决定的。 float的指数位有8位，而double的指数位有11位，分布如下： float： 1bit（符号位） 8bits（指数位） 23bits（尾数位） double： 1bit（符号位） 11bits（指数位） 52bits（尾数位） 于是，float的指数范围为-127~+128，而double的指数范围为-1023~+1024，并且指数位是按补码的形式来划分的。其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。 float的范围为-2^128 ~ +2^128，也即-3.40E+38 ~ +3.40E+38；double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。 精度 float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。 float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字； double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UG表格打断]]></title>
      <url>%2F2017%2F03%2F06%2FUG%E8%A1%A8%E6%A0%BC%E6%89%93%E6%96%AD%2F</url>
      <content type="text"><![CDATA[创建表格 int CreateTabnot() { tag_t tTabular = NULL_TAG; int nRows = 0, nColumns = 0; //零时行列数量 tag_t tRows[200] = { NULL_TAG }; //行; tag_t tColumns[20] = { NULL_TAG }; //列; tag_t tCell[200 * 20] = { NULL_TAG }; //单元各 UF_TABNOT_section_prefs_t prefs; double origin[3] = { 0.0, 0.0, 0.0 }; //表格标注位置; UF_TABNOT_ask_default_section_prefs(&amp;prefs); //获取默认设置; prefs.overflow_spacing = 200; //偏移延拓部分（只用于在同一片上的表继续）的距离; prefs.max_height = 200; //最大高度,超过该高度表格会打断; prefs.header_location = UF_TABNOT_header_location_above; //显示标题的位置; prefs.max_height = 250.0; //表格打断最大高度,其值为0时表示不打断; prefs.overflow_direction = UF_TABNOT_overflow_left; //表格溢出的方向; prefs.overflow_spacing = 0.0; //溢出后的距离; prefs.attach_point = UF_TABNOT_attach_point_top_left; //创建表格输入点在表格上的位置; prefs.use_double_width_border = false; //是否显示双边框; prefs.border_width = 0.0; //双边框的距离； UF_TABNOT_create(&amp;prefs, origin, &amp;tTabular); UF_TABNOT_ask_nm_rows(tTabular, &amp;nRows); //得到表格标注行数 UF_TABNOT_ask_nm_columns(tTabular, &amp;nColumns); //得到表格标注列数 //删除一行列(子留下一行一列)，注意删除必须有顺序的删除 for (int i = 0; i&lt;nRows - 1; i++) { UF_TABNOT_ask_nth_row(tTabular, tTabular - i - 1, &amp;tRows[nRows - i - 1]); //得到表格标注一行 UF_TABNOT_remove_row(tRows[nRows - i - 1]); //删除一行 } for (int i = 0; i&lt;nColumns - 1; i++) { UF_TABNOT_ask_nth_column(tTabular, nColumns - i - 1, &amp;tColumns[nColumns - i - 1]); //得到表格标注一列 UF_TABNOT_remove_column(tColumns[nColumns - i - 1]); //删除一列 } return 0; } 创建行列int CreateRowCol(tag_t tTabular, int nRow, int nCol) { UF_TABNOT_cell_prefs_t cell_prefs; tag_t tRows[200] = { NULL_TAG }; //行; tag_t tColumns[20] = { NULL_TAG }; //列; tag_t tCell[200 * 20] = { NULL_TAG }; //单元格 //初始化单元格属性; UF_TABNOT_set_default_cell_prefs(&amp;cell_prefs); cell_prefs.text_font = 1; //字体; cell_prefs.text_height = 3.0; //文本高度; cell_prefs.text_aspect_ratio = 0.7; //文本纵横比; cell_prefs.text_angle = 0; //文本角度; cell_prefs.text_slant = 0; //文本倾斜角度; cell_prefs.char_space_factor = 0.1; //文本空间因数; cell_prefs.text_color = 1; //文本颜色; cell_prefs.text_density = 1; //文本密度1：正常，2：重，3：薄，0：使用默认; cell_prefs.bottom_line_cfw[0] = 105; //横底线颜色; cell_prefs.bottom_line_cfw[1] = 1; //横底线线型; cell_prefs.bottom_line_cfw[2] = 1; //横底线宽度; cell_prefs.right_line_cfw[0] = 105; //竖底线颜色; cell_prefs.right_line_cfw[1] = 1; //竖底线线型; cell_prefs.right_line_cfw[2] = 1; //竖底线宽度; UF_TABNOT_ask_nth_row(tTabular, 0, &amp;tRows[0]); //得到表格标注一行 UF_TABNOT_ask_nth_column(tTabular, 0, &amp;tColumns[0]); //得到表格标注一列 UF_TABNOT_set_row_height(tRows[0], 10); //设置表格标注一行高度 UF_TABNOT_set_column_width(tColumns[0], 20); //设置表格标注一列宽度 //添加行列 for (int i = 0; i&lt;20; i++)//添加行数量; { tag_t tAppRow = NULL_TAG; UF_TABNOT_create_row(5.0, &amp;tAppRow); UF_TABNOT_add_row(tTabular, tAppRow, UF_TABNOT_APPEND); //添加一行的方法 } for (int i = 0; i&lt;5; i++)//列的数量 { tag_t tAppColumn = NULL_TAG; UF_TABNOT_create_column(15, &amp;tAppColumn); UF_TABNOT_add_column(tTabular, tAppColumn, UF_TABNOT_APPEND);//添加一列的方法 } return 0; } 单元格操作int CellOperation(tag_t tTabular, tag_t tRows[200], tag_t tColumns[20]) { tag_t tCell[200 * 20] = { NULL_TAG }; //单元格 UF_TABNOT_cell_prefs_t cell_prefs; //合并单元格，创建表格标题 UF_TABNOT_ask_nth_row(tTabular, 0, &amp;tRows[0]); //得到表格标注一行; UF_TABNOT_ask_nth_column(tTabular, 0, &amp;tColumns[0]); //得到表格标注第1列 UF_TABNOT_ask_cell_at_row_col(tRows[0], tColumns[0], &amp;tCell[0]); //输入行列柱获得单元格; UF_TABNOT_ask_cell_at_row_col(tRows[0], tColumns[1], &amp;tCell[1]); //输入行列柱获得单元格; UF_TABNOT_merge_cells(tCell[0], tCell[1]); //输入合并单元表格(start_cell，end_cell); char SzCellText[32] = &quot;测试&quot;; UF_TABNOT_ask_nth_column(tTabular, 0, &amp;tColumns[0]); //得到表格标注第1列 UF_TABNOT_ask_cell_at_row_col(tRows[0], tColumns[0], &amp;tCell[0]); //输入行列柱获得细胞（表格位置） UF_TABNOT_set_cell_text(tCell[0], SzCellText); //设置单元格内容; //UF_TABNOT_cell_prefs_s cell_prefs; //单元格属性设置; UF_TABNOT_ask_cell_prefs(tCell[0], &amp;cell_prefs); //获取单元格默认设置; cell_prefs.text_color = 1; //文本颜色; cell_prefs.text_height = 3.0; //高度 cell_prefs.text_density = 2; //文本密度1:正常,2:重,3:薄,0:使用默认 cell_prefs.format = UF_TABNOT_format_text; //单元格格式 UF_TABNOT_format_text =内容是文本 cell_prefs.horiz_just = UF_TABNOT_just_center; //文字位置中心 UF_TABNOT_set_cell_prefs(tCell[0], &amp;cell_prefs); return 0; } 打断表格（需要将表格打断长度不一样时，若无此需要，只需执行上面代码即可）获取表格陪打断成几列表格 int SectionTabnot(tag_t tTabnote) { int nCount=0; //表格被打断成了几段; tag_t tSection=NULL_TAG; //打断的表格TAG; UF_TABNOT_section_prefs_t section_prefs;//打断后表格的属性; irc=UF_TABNOT_ask_nm_sections(tTabular,&amp;nCount); if(!irc) for(int i=0;i&lt;nCount;i++)//第i个打断后的表格; { int nTemp=i;//UG内置函数的一个错误会导致i变为0,所以将其赋值给另一个变量，让其不受错误的变化； irc=UF_TABNOT_ask_nth_section(tTabnote,i,&amp;tSection);//获取打断后的第nTemp个表格，这里函数执行后会把i变成0; //获取属性; if(!irc) { irc=UF_TABNOT_ask_section_prefs(tSection,&amp;section_prefs);//获取打断后表格的属性; //设置打断最大长度; section_prefs.max_height=180.0;//这里在每次循环可设置不同的值; } //设置打断表格的属性; if(!irc) irc=UF_TABNOT_set_section_prefs(tSection,&amp;section_prefs); //询问表格打断成了多少段; if(!irc) irc=UF_TABNOT_ask_nm_sections(tTabular,&amp;nCount); i=nTemp; } report(irc); } 打印错误 void report(irc) { if (irc) { char szMessg[133]=&quot;&quot;; UF_get_fail_message(irc, szMessg); uc1601(szMessg,1); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Welcome]]></title>
      <url>%2F2017%2F03%2F04%2Fhello-world%2F</url>
      <content type="text"><![CDATA[你好，欢迎来到我的个人技术博客。]]></content>
    </entry>

    
  
  
</search>
